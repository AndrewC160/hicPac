#' @title Patchwork OGM contigs
#'
#' @description
#' Given a table of OGM contigs (typically from clugPac::parse_ogm_reads()) and
#' a table of HiC regions compatible with other patchwork_* functions (produced
#' by hicPac::patchwork_bins()), split OGM XMAP/CMAP/contig annotations into
#' contig panels compatible with other hicPac::patchwork_* functions and return
#' ggplot object illustrating them. If needed,a Cooler file and list of genomic
#' ranges can be provided in lieu of regions_tb, but these will just be used to
#' generate regions_tb anyway.
#'
#' Function can also return a formatted table with region- and strand-oriented
#' bin ID coordinates (bin_start/end) and y-values based on contig IDs. Intended
#' for use with HiC patchwork_* functions, so it assumes that the regions_tb
#' file is formatted as such, but in principle this table can be generated
#' independently for use elsewhere.
#'
#' NOTE: "junctions_only" currently broken, need to be able to recognize
#' duplicated segments as duplicates (if the same genomic position is included
#' twice it does not count to find a contig between them), but seems to drop
#' some non-junction contigs as well.
#'
#' @param tb_ogm_in Tibble of OGM contig/XMAP/CMAP data, typically produced by clugPac::parse_ogm_reads().
#' @param regions_tb Tibble of genomic regions ordered from 5' to 3', including strand information to denote orientation. Typically generated by hicPac::patchwork_regions().
#' @param hic_file Cooler file which can be used to extract HiC bin locations if regions_tb is not provided.
#' @param gr_segments GRanges object of genomic regions stitched, listed in order of 5' to 3' with strand indicating orientation. Only used if regions_tb is not provided.
#' @param label_contigs Boolean; should contig IDs be included? Defaults to FALSE.
#' @param label_xmaps Boolean; should XMAP IDs be included? Defaults to FALSE.
#' @param contig_size Size of contig labels. Defaults to 4.
#' @param xmap_size Size of XMAP labels. Defaults to 3.
#' @param junctions_only Boolean; should contigs with no XMAPs between stitched regions be omitted? Defaults to TRUE.
#' @param return_tables_only Boolean; should plotting be skipped and tables provided instead? Defaults to FALSE, otherwise three tables are returned with contig, xmap, and contig data.
#'
#' @import tidyr
#' @import data.table
#' @import clugPac
#' @import dplyr
#' @import ggplot2
#' @import tibble
#' @import magrittr
#'
#' @export

patchwork_ogm_contigs  <- function(tb_ogm_in,regions_tb=NULL,hic_file=NULL,gr_segments=NULL,label_contigs=FALSE,label_xmaps=FALSE,contig_size=3,xmap_size=2,junctions_only=TRUE,return_tables_only=FALSE,junction_linewidth=0.5,junction_line_color="gray30",junction_linetype="solid"){
  filter  <- dplyr::filter
  rename  <- dplyr::rename
  mutate  <- dplyr::mutate
  select  <- dplyr::select
  arrange <- dplyr::arrange

  if(is.null(regions_tb)){
    if(is.null(hic_file) | is.null(gr_segments)) stop("Either a regions table from patchwork_bins() is required or both the hic_file and gr_segments arguments must be provided.")
    regions_tb  <- patchwork_bins(gr_list = gr_segments,hic_file = fl_hic)
  }
  regions_tb  <- filter(regions_tb,!trans_region) %>%
    mutate(width = abs(end1 - start1)) %>%
           # start = ifelse(start1 > end1,end1,start1),
           # end = ifelse(start1 > end1, start1,end1)) %>%
    # mutate(start1=start,end1=end) %>%
    # select(-start,-end) %>%
    group_by(seqnames1,start1,end1) %>%
    mutate(unq_region = cur_group_id()) %>%
    ungroup %>%
    select(region,unq_region,everything())

  x_rng   <- c(0,max(regions_tb$bin_alt1_2))
  x_ax    <- patchwork_xaxis(regions_tb)

  # Get XMAP contigs.
  tb_x <- tb_ogm_in %>%
    mutate(end = start + 6) %>%
    patchwork_annotations(regions_tb) %>%
    left_join(by="region",relationship = "many-to-many",
      select(regions_tb,region,unq_region)
    ) %>%
    group_by(unq_region) %>%
    mutate(junction_spanning = length(unique(region))>1) %>%
    ungroup

  if(junctions_only){
    tb_x <- filter(tb_x,junction_spanning)
  }

  contig_order <- tb_x %>%
    group_by(contig_id) %>%
    summarize(min_pos = min(c(bin_start,bin_end)),
              max_pos = max(c(bin_start,bin_end)),
              max_xmap= max(xmap_conf),
              .groups="drop") %>%
    arrange(desc(min_pos),desc(max_pos)) %>%
    mutate(contig_id = as.character(contig_id)) %>%
    select(contig_id) %>%
    unlist %>%
    unique

  tb_x <- tb_x %>%
    mutate(contig_id = factor(as.character(contig_id),levels=contig_order)) %>%
    mutate(ymax=as.integer(contig_id),
           ymin=ymax-1)

  tb_l <- tb_x %>%
    group_by(region,contig_id,xmap_id,xmap_conf,ymin,ymax,junction_spanning) %>%
    summarize(bin_start = min(c(bin_start,bin_end)),
              bin_end = max(c(bin_start,bin_end)),
              .groups="drop") %>%
    mutate(y = (ymin + ymax)/2)

  tb_c <- tb_l %>%
    mutate(y = ymin+0.5,
           yend = y) %>%
    group_by(contig_id) %>%
    summarize(x=min(bin_start),
              xend=max(bin_end),
              y = first(y),
              .groups="drop") %>%
    arrange(desc(x))

  if(return_tables_only){
    p_out <- list(tags=tb_x,
                  xmaps=tb_l,
                  contigs=tb_c)
  }else{
    p_theme <- gg_theme("genome",
                        axis.text.x = element_text(angle=45,hjust=1,vjust=1),
                        axis.ticks.x = element_blank())
    if(nrow(tb_x) == 0){
      p <- ggplot() +
        scale_x_continuous(name = x_ax$title,
                           limits= x_rng,
                           expand= c(0,0),
                           breaks = x_ax$breaks,
                           labels = names(x_ax$breaks)) +
        scale_y_continuous(expand = c(0,0),
                           limits=y_rng) +
        p_theme
    }else{
      p_out <- ggplot(tb_x,
                      aes(x=(bin_start + bin_end)/2,
                          xend=(bin_start + bin_end)/2,
                          y=ymin+0.1,yend=ymax-0.1,
                          label=contig_id,
                          color=log2(coverage))) +
        scale_x_continuous(name = x_ax$title,
                           limits=x_rng,
                           expand=c(0,0),
                           breaks = x_ax$breaks,
                           labels = names(x_ax$breaks)) +
        scale_y_continuous(expand=c(0,0)) +
        scale_color_gradient(name="log2(Coverage)",low="blue",high="chartreuse") +
        scale_fill_gradient(name="log2(XMAP conf.)",low="white",high="black") +
        geom_vline(xintercept = regions_tb$bin_alt1_2,color="black",linetype="dotted") +
        geom_segment(tb_c,mapping=aes(x=x,xend=xend,y=y,yend=y),inherit.aes=FALSE,
                     linewidth=junction_linewidth,color=junction_line_color,linetype=junction_linetype,
                     alpha=1) +
        geom_rect(data=tb_l,
                  mapping=aes(xmin=bin_start,xmax=bin_end,
                              ymin=ymin+0.1,ymax=ymax-0.1,
                              fill=log2(xmap_conf)),
                  inherit.aes=FALSE) +
        geom_segment(alpha=1) +
        p_theme

      if(label_contigs){
        p_out <- p_out +
          geom_text(data=tb_c,mapping=aes(x=x,y=y,label=contig_id),
                    inherit.aes=FALSE,hjust=1,vjust=0.5,size=contig_size,
                    color="gray20")
      }
      if(label_xmaps){
        p_out <- p_out +
          geom_text(data=tb_l,mapping=aes(x=(bin_start+bin_end)/2,
                                          y=y,label=xmap_id),
                    inherit.aes=FALSE,hjust=0.5,vjust=0.5,size=xmap_size,
                    color="black")
      }
    }
  }
  return(p_out)
}
